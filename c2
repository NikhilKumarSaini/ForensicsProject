import os
import numpy as np
from PIL import Image
import cv2


def compute_compression_score(forensic_output_dir: str) -> float:
    """
    Compression tampering score.

    Output:
    - 0.0  → clean (no compression-based manipulation)
    - >0.0 → severity of manipulation (0–1)

    Key fixes:
    - Filters benign text-line compression noise
    - Preserves real row-based & logo manipulations
    """

    comp_dir = os.path.join(forensic_output_dir, "Compression")
    if not os.path.exists(comp_dir):
        return 0.0

    page_scores = []

    for fname in os.listdir(comp_dir):
        if not fname.lower().endswith(".jpg"):
            continue

        path = os.path.join(comp_dir, fname)

        # ---------------- Load image ----------------
        try:
            gray = np.array(
                Image.open(path).convert("L"),
                dtype=np.float32
            ) / 255.0
        except Exception:
            continue

        h, w = gray.shape
        total_pixels = h * w

        # =====================================================
        # PRE-CHECK: Flat / empty compression image → CLEAN
        # =====================================================
        if np.max(gray) < 0.05:
            page_scores.append(0.0)
            continue

        if np.mean(gray > 0.05) < 0.001:
            page_scores.append(0.0)
            continue

        # =====================================================
        # STEP 1: Residual activation
        # =====================================================
        active_mask = gray > 0.02
        if np.sum(active_mask) < 120:
            page_scores.append(0.0)
            continue

        active_vals = gray[active_mask]

        # =====================================================
        # STEP 2: Strong residuals
        # =====================================================
        high_thresh = np.percentile(active_vals, 95)
        high_mask = gray >= high_thresh

        if np.sum(high_mask) < 60:
            page_scores.append(0.0)
            continue

        # =====================================================
        # STEP 3: Connected components
        # =====================================================
        mask_uint8 = (high_mask * 255).astype(np.uint8)
        num_labels, labels, stats, _ = cv2.connectedComponentsWithStats(
            mask_uint8, connectivity=8
        )

        region_info = []

        for i in range(1, num_labels):
            area = stats[i, cv2.CC_STAT_AREA]
            x, y, bw, bh, _ = stats[i]

            if area < 120:
                continue
            if bw < 6 or bh < 6:
                continue

            region_info.append((area, x, y, bw, bh))

        # =====================================================
        # CLEAN TEXT-LINE NOISE FILTER (FIXED)
        # =====================================================
        if len(region_info) >= 5:
            ys = [r[2] for r in region_info]
            areas = [r[0] for r in region_info]

            y_std = np.std(ys)
            area_std = np.std(areas) / (np.mean(areas) + 1e-6)

            # Clean text noise:
            # aligned AND uniform region sizes
            if y_std < 12 and area_std < 0.35:
                page_scores.append(0.0)
                continue

        # =====================================================
        # HARD CLEAN GATE
        # =====================================================
        if not region_info:
            page_scores.append(0.0)
            continue

        # =====================================================
        # SEVERITY SCORING (YOUR LOGIC)
        # =====================================================

        # 1️⃣ Energy
        energy = float(np.mean(gray[high_mask]))

        # 2️⃣ Concentration / area
        high_pixel_count = int(np.sum(high_mask))
        concentration = high_pixel_count / total_pixels
        area_ratio = concentration

        # 3️⃣ Largest patch
        region_areas = [r[0] for r in region_info]
        largest_patch_ratio = max(region_areas) / total_pixels

        # 4️⃣ Number of manipulation locations
        manipulation_count = len(region_areas)
        manipulation_score = min(1.0, manipulation_count / 4.0)

        raw_score = (
            0.30 * energy +
            0.20 * concentration * 10.0 +
            0.15 * area_ratio * 10.0 +
            0.20 * largest_patch_ratio * 15.0 +
            0.15 * manipulation_score
        )

        score = min(1.0, raw_score)
        page_scores.append(score)

    if not page_scores:
        return 0.0

    return float(round(max(page_scores), 3))
